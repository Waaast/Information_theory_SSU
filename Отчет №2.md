# Отчёт по лабораторной работе №2  
**Выполнил:** Шмелев Никита, группа 606-42  
## Тема: «Методы эффективного кодирования некоррелированной последовательности знаков»

---

### Интерфейс программы

На рисунке показано главное окно программы «Кодирование Шеннона–Фано и Хаффмена»
Пользователь выполняет следующие действия:
- нажимает кнопку «Загрузить сообщение» и выбирает текстовый файл в кодировке UTF-8 или CP1251;
-	программа автоматически приводит текст к нижнему регистру (регистр не учитывается: «Н» и «н» считаются одним символом);
-	рассчитывает частоты появления символов и их вероятности;
-	выполняет построение кодов по методам Шеннона–Фано и Хаффмена;
-	отображает две таблицы: Символ, Кол-во, Вероятность, Код, — по одной для каждого метода.

В нижней части окна под каждой таблицей выводятся рассчитанные значения:
-	энтропия источника H(Z),
-	Среднее число символов на один знак сообщения,
-	избыточность кода по формуле D = (L - H(Z))/L.

Таким образом, окно позволяет наглядно сравнить эффективность методов кодирования при одинаковом исходном тексте.

> **Рисунок 1 — Главное окно программы «Кодирование Шеннона–Фано и Хаффмена»»**
<img width="1582" height="2004" alt="img1" src="https://github.com/user-attachments/assets/46399e70-2c16-4202-b114-ced326e2b3e6" />

---

### Пример рабыты кода с сообщением из методички

> **Рисунок 2 — Расчёт для сообщения из методички**  

<img width="1576" height="2008" alt="image" src="https://github.com/user-attachments/assets/8591e082-c343-424c-97b5-e7621d046965" />

---

### Пример рабыты с текстом ~ 1500 слов

Взят отрывок произведения Рэя Бредбери «451 градус по Фаренгейту» (1510 слов)

> **Рисунок 3 — Первая часть расчётов для большего сообщения  

<img width="1582" height="2012" alt="image" src="https://github.com/user-attachments/assets/2ec9bcbc-f193-4ade-ab35-1796ffe2b9de" />

> **Рисунок 4 — Вторая часть расчётов для большего сообщения

<img width="1572" height="2014" alt="image" src="https://github.com/user-attachments/assets/bbf54e1c-db05-4d5d-a8bd-c8c622b5ffb9" />

---

### Структура проекта

Код программы состоит из одного файла:
	•	main.py — содержит весь функционал: интерфейс PySide6, загрузку текста из файла, вычисление частот и вероятностей символов, реализацию кодов Шеннона–Фано и Хаффмена, а также расчёт энтропии, средней длины и избыточности кода.

---

### Построение кодов

- build_huffman_codes(stats): реализует алгоритм Хаффмена — последовательно объединяет два наименьших веса, строит дерево и обходит его, назначая коды (0/1). Возвращает dict(symbol → code).
- build_shannon_fano_codes(stats): реализует метод Шеннона–Фано — сортирует символы по убыванию вероятности, делит список на две подгруппы с близкими суммами вероятностей, добавляет 0/1 и рекурсивно повторяет. Добавлены проверки границ, чтобы избежать зацикливания.

---

### Объяснение кода main.py

```python
import sys, math, collections
from dataclasses import dataclass
from typing import List, Dict, Optional
from PySide6.QtWidgets import (
    QApplication, QWidget, QMainWindow, QHBoxLayout, QVBoxLayout, QLabel, QPushButton,
    QFileDialog, QTableWidget, QTableWidgetItem, QFormLayout, QGroupBox, QHeaderView
)
from PySide6.QtCore import Qt
```
> Импорт библиотек: системные модули, математика, подсчёт частот, dataclass, аннотации типов, а также UI-компоненты из PySide6 для создания интерфейса.
```python
@dataclass
class SymbolStat:
    symbol: str
    count: int
    prob: float
    code: str = ""
```
> Структура данных для хранения информации о символе: сам символ (`symbol`), сколько раз встретился (`count`), его вероятность (`prob`) и код после кодирования (`code`). Dataclass автоматом создаёт конструктор и repr.
```python
def count_frequencies(text: str):
    return collections.Counter(text)
```
> Возвращает словарь `символ → количество`, используя `Counter`.

```python
def calc_entropy(probs):
    return -sum(p * math.log2(p) for p in probs if p > 0)
```
> Вычисляет энтропию Шеннона: `H = - Σ p * log2(p)`. Пропускает нулевые вероятности.

```python
def average_code_length(stats):
    return sum(s.prob * len(s.code) for s in stats if s.prob > 0)
```
> Средняя длина кода L: сумма `probability * length(code)` по всем символам.
```python
def build_huffman_codes(stats: List[SymbolStat]) -> Dict[str,str]:
    import heapq
    class Node:
        def __init__(self, p, s=None, l=None, r=None):
            self.p, self.s, self.l, self.r = p,s,l,r
        def __lt__(self,o): return self.p<o.p
    heap=[Node(s.prob,s.symbol) for s in stats]
    heapq.heapify(heap)
    if len(heap)==1: return {heap[0].s:"0"}
    while len(heap)>1:
        a,b=heapq.heappop(heap),heapq.heappop(heap)
        heapq.heappush(heap,Node(a.p+b.p,None,a,b))
    root=heap[0]
    codes={}
    def walk(n,prefix):
        if n.s is not None: codes[n.s]=prefix or "0";return
        walk(n.l,prefix+"0");walk(n.r,prefix+"1")
    walk(root,"")
    return codes
```
> Реализация алгоритма Хаффмана: строит дерево вероятностей через `heapq`, затем рекурсивно обходит дерево и формирует код — 0 по левому ребру, 1 по правому.
```python
def build_shannon_fano_codes(stats: List[SymbolStat]) -> Dict[str,str]:
    if not stats:
        return {}
    stats = sorted(stats, key=lambda s: (-s.prob, s.symbol))
    if len(stats) == 1:
        return {stats[0].symbol: "0"}

    codes: Dict[str, str] = {s.symbol: "" for s in stats}

    def split(lo: int, hi: int):
        if hi - lo <= 1:
            return
        total = sum(stats[i].prob for i in range(lo, hi))
        half = total / 2.0
        acc = 0.0
        cut = -1
        for i in range(lo, hi):
            nxt = acc + stats[i].prob
            if nxt >= half:
                left_diff = abs(acc - (total - acc))
                right_diff = abs(nxt - (total - nxt))
                cut = i if left_diff <= right_diff else i + 1
                break
            acc = nxt
        if cut == -1:
            cut = (lo + hi) // 2
        if cut <= lo:
            cut = lo + 1
        if cut >= hi:
            cut = hi - 1

        for i in range(lo, cut):
            codes[stats[i].symbol] += "0"
        for i in range(cut, hi):
            codes[stats[i].symbol] += "1"

        split(lo, cut)
        split(cut, hi)

    split(0, len(stats))
    return codes
```
> Алгоритм Шеннона–Фано: сортирует символы по вероятности, делит на две группы с близкой суммой вероятностей, левой группе добавляет `0`, правой — `1`. Рекурсивно строит код.
```python
class CodePanel(QWidget):
    def __init__(self, name:str):
        super().__init__()
        layout=QVBoxLayout(self)
        self.title=QLabel(f"<b>Кодирование {name}</b>")
        layout.addWidget(self.title)
        self.table=QTableWidget(0,4)
        self.table.setHorizontalHeaderLabels(["Символ","Кол-во","Вероятность","Код"])
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.verticalHeader().setVisible(False)
        layout.addWidget(self.table,1)

        box=QGroupBox("Результаты")
        form=QFormLayout(box)
        self.lblH=QLabel("—")
        self.lblL=QLabel("—")
        self.lblR=QLabel("—")
        form.addRow("Энтропия H(Z):",self.lblH)
        form.addRow("Среднее число символов \n на один знак сообщения",self.lblL)
        form.addRow("Избыточность кода",self.lblR)
        layout.addWidget(box)
```
> Панель GUI: заголовок, таблица результатов (символ–количество–вероятность–код) и блок с вычисленными значениями энтропии, средней длины кодирования и избыточности.
```python
def populate(self,stats:List[SymbolStat],H:float):
    self.table.setRowCount(0)
    for s in stats:
        r=self.table.rowCount();self.table.insertRow(r)
        for c,val in enumerate([s.symbol,str(s.count),f"{s.prob:.6f}",s.code]):
            item=QTableWidgetItem(val)
            item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEditable)
            self.table.setItem(r,c,item)
    L=average_code_length(stats)
    R=(L-H)/L if L>0 else 0
    self.lblH.setText(f"{H:.6f}")
    self.lblL.setText(f"{L:.6f}")
    self.lblR.setText(f"{R:.6f}")
```
> Добавляет строки в таблицу, блокирует редактирование ячеек, вычисляет L и избыточность R, выводит значения в GUI.
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Кодирование Шеннона–Фано и Хаффмена")
        self.resize(800,1200)
        main=QWidget();self.setCentralWidget(main)
        layout=QVBoxLayout(main)
        self.btnLoad=QPushButton("Загрузить сообщение")
        self.btnLoad.clicked.connect(self.load_file)
        layout.addWidget(self.btnLoad)

        self.panSF=CodePanel("Шеннона–Фано")
        self.panHF=CodePanel("Хаффмена")
        panels=QHBoxLayout()
        panels.addWidget(self.panSF,1)
        panels.addWidget(self.panHF,1)
        layout.addLayout(panels,1)
```
> Главное окно приложения: кнопка загрузки файла + две панели для отображения результатов кодирования.
```python
def load_file(self):
    path,_=QFileDialog.getOpenFileName(self,"Выберите текстовый файл","","Текстовые файлы (*.txt);;Все файлы (*.*)")
    if not path: return
    try:
        txt=open(path,encoding="utf-8").read()
    except Exception:
        txt=open(path,encoding="cp1251").read()
    txt=txt.lower()
    stats=self._build_stats(txt)
    H=self._entropy(stats)
    sf_codes=build_shannon_fano_codes(stats)
    sf_stats=[SymbolStat(s.symbol,s.count,s.prob,sf_codes.get(s.symbol,"")) for s in stats]
    self.panSF.populate(sf_stats,H)
    hf_codes=build_huffman_codes(stats)
    hf_stats=[SymbolStat(s.symbol,s.count,s.prob,hf_codes.get(s.symbol,"")) for s in stats]
    self.panHF.populate(hf_stats,H)
```
> Открывает файл (UTF-8 → fallback CP1251), считает энтропию и отображает результаты кодирования двумя методами.
```python
def _build_stats(self,text:str)->List[SymbolStat]:
    freq=count_frequencies(text)
    total=sum(freq.values())
    stats=[SymbolStat(ch,c,c/total) for ch,c in freq.items() if ch.strip()!="" or ch==" "]
    stats.sort(key=lambda x:-x.count)
    return stats
```
> Формирует список `SymbolStat`, исключая невидимые символы кроме пробела.

```python
def _entropy(self,stats):
    return calc_entropy([s.prob for s in stats])
```
> Считает энтропию на основе вероятностей.
```python
if __name__=="__main__":
    app=QApplication(sys.argv)
    w=MainWindow();w.show()
    sys.exit(app.exec())
```
> Создаёт приложение, создаёт окно и запускает GUI-цикл.
