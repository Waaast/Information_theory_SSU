# Отчёт по лабораторной работе №1  
**Выполнил:** Шмелев Никита, группа 606-42  
## Тема: «Энтропия объединения двух источников. Количество информации как мера снятой неопределённости»

---

### Интерфейс программы

На рисунке показано **главное окно приложения**, где пользователь:
- выбирает тип исходных данных (совместные или условные вероятности);
- задаёт размеры матриц (число строк и столбцов);
- при необходимости вводит номер варианта (на расчёты не влияет, но отображается в выводе);
- вводит вероятности для вычисления **энтропий** и **взаимной информации**.  

В нижней части окна расположены кнопки **«Рассчитать»** и **«Очистить ввод»**.  
Справа отображается окно вывода результатов расчётов.

> **Рисунок 1 — Главное окно программы «Теория информации — ЛР: совместные и условные вероятности»**  

<img width="1171" height="736" alt="Снимок экрана 2025-10-16 в 19 34 37" src="https://github.com/user-attachments/assets/8e9bf93e-596a-44b9-bcca-b15e2105017f" />

---

### Случай a) — Дана матрица совместных вероятностей P(A,B)

На рисунке показан пример заполнения таблицы и вывода результатов при вводе матрицы совместных вероятностей.  
Программа автоматически вычисляет:
- Ансамбли A и B;
- Матрицы условных вероятностей P(A|B) и P(B|A);
- энтропии H(A), H(B), H(A,B), H(A|B), H(B|A);
- взаимную информацию I(A;B).

> **Рисунок 2 — Расчёт для случая a) (P(A,B))**  

<img width="2341" height="1471" alt="a)" src="https://github.com/user-attachments/assets/2e29645e-050d-4eb2-92a5-f85865481598" />

---

### Случай b) — Дана матрица условных вероятностей P(A|B) и ансамбль B

В этом варианте задаётся матрица условных вероятностей **P(A|B)** (каждый столбец суммируется к 1) и ансамбль B.  
На основе этих данных программа автоматически вычисляет:
- матрицу совместных вероятностей P(A,B);
- Ансамбль A;
- матрицу условных вероятностей P(B|A);
- энтропии H(A), H(B), H(A,B), H(A|B), H(B|A);
- взаимную информацию I(A;B).


> **Рисунок 3 — Расчёт для случая b) (P(A|B), P(B))**  

<img width="1171" height="736" alt="b)" src="https://github.com/user-attachments/assets/cdc91e5e-f47a-42da-96bb-9c87e2e90a5f" />

---

### Случай c) — Дана матрица условных вероятностей P(B|A) и ансамбль A

В этом режиме задаются **P(B|A)** (строки суммируются к 1) и **P(A)**.  
На основе этих данных программа автоматически вычисляет:
- матрицу совместных вероятностей P(A,B);
- Ансамбль B;
- матрицу условных вероятностей P(A|B);
- энтропии H(A), H(B), H(A,B), H(A|B), H(B|A);
- взаимную информацию I(A;B).
> **Рисунок 4 — Расчёт для случая c) (P(B|A), P(A))**  

<img width="1170" height="738" alt="c)" src="https://github.com/user-attachments/assets/097997cb-89a8-46b7-9e2d-4a3b8d871cb8" />

---

### Структура проекта

Код программы разделён на три логических файла:

- **main.py** — графический интерфейс (создание окон/таблиц/кнопок, чтение ввода, вывод результатов и вызов вычислений).
- **calcs.py** — все математические вычисления по теории информации (матрицы совместных и условных вероятностей, энтропии, взаимная информация).
- **utils.py** — служебное форматирование чисел/векторов/матриц для красивого и выровненного текста в окне результатов.

---

### Объяснение кода main.py

#### Импорты

``` python 
import sys
import numpy as np
from PySide6.QtWidgets import (
    QApplication, QWidget, QGridLayout, QGroupBox, QVBoxLayout, QHBoxLayout,
    QLabel, QLineEdit, QPushButton, QComboBox, QSpinBox, QTableWidget,
    QTableWidgetItem, QPlainTextEdit, QHeaderView
)
from PySide6.QtGui import QFont
from PySide6.QtCore import Qt

import calcs as C
import utils as U
```
> Подключение модулей (sys), numpy для работы с числами, виджеты Qt для интерфейса (окна, таблицы, кнопки и т. д.), модули calcs — там формулы и расчёты (вызываем как C.from_...) и utils — форматирование вывода (функции U.fmt_*).

#### Генерация подписей A1..Am и B1..Bn

``` python 
def gen_labels(prefix: str, k: int):
    """A1..Ak или B1..Bk."""
    return [f"{prefix}{i+1}" for i in range(k)]
```
> Маленькая функция для подписи заголовков строк/столбцов таблиц: по префиксу A или B создаёт список ["A1","A2",…] или ["B1","B2",…] нужной длины.

#### Виджет ввода матрицы m×n

``` python 
class MatrixInput(QGroupBox):
    def __init__(self, title, m=2, n=2, parent=None):
        super().__init__(title, parent)
        self.table = QTableWidget(m, n)
        self.table.horizontalHeader().setVisible(True)
        self.table.verticalHeader().setVisible(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.table.setAlternatingRowColors(True)
        self.table.setShowGrid(True)
        lay = QVBoxLayout(self)
        lay.addWidget(self.table)
        self.set_headers(gen_labels("A", m), gen_labels("B", n))
    def set_size(self, m, n):
        self.table.setRowCount(m)
        self.table.setColumnCount(n)
        self.set_headers(gen_labels("A", m), gen_labels("B", n))
    def set_headers(self, row_labels, col_labels):
        self.table.setVerticalHeaderLabels(row_labels)
        self.table.setHorizontalHeaderLabels(col_labels)
    def read(self):
        m = self.table.rowCount()
        n = self.table.columnCount()
        A = np.zeros((m, n), dtype=float)
        for i in range(m):
            for j in range(n):
                item = self.table.item(i, j)
                txt = item.text().strip() if item else ""
                A[i, j] = float(txt) if txt else 0.0
        return A
```
> это обёртка над QTableWidget для ввода матриц (например, P(A,B), P(A|B), P(B|A)). Включены заголовки строк/столбцов, авто-растяжение столбцов, сетка и чередование цветов строк для читаемости. set_size() меняет размер матрицы и автоматически подписи (A1..Am, B1..Bn). read() считывает таблицу

#### Виджет ввода ансамбля

``` python 
class VectorInput(QGroupBox):
    def __init__(self, title, k=2, parent=None):
        super().__init__(title, parent)
        self.table = QTableWidget(1, k)
        self.table.horizontalHeader().setVisible(True)
        self.table.verticalHeader().setVisible(False)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setAlternatingRowColors(True)
        self.table.setShowGrid(True)
        lay = QVBoxLayout(self)
        lay.addWidget(self.table)
        self.set_header_labels(gen_labels("B", k))  # дефолт
    def set_size(self, k):
        self.table.setColumnCount(k)
        labels = getattr(self, "_col_labels", gen_labels("B", k))
        if len(labels) != k:
            prefix = labels[0][0] if labels else "B"
            labels = gen_labels(prefix, k)
        self.set_header_labels(labels)
    def set_header_labels(self, col_labels):
        self._col_labels = col_labels[:]  # запомним
        self.table.setHorizontalHeaderLabels(col_labels)
    def read(self):
        k = self.table.columnCount()
        v = np.zeros(k, dtype=float)
        for j in range(k):
            it = self.table.item(0, j)
            txt = it.text().strip() if it else ""
            v[j] = float(txt) if txt else 0.0
        return v
```
> Аналог матричного виджета, но для ансамбля — одна строка и k столбцов. Умеет менять размер, держит «префикс» меток (A или B) и считывает данные.

#### Главное окно и сборка интерфейса

``` python 
class MainWin(QWidget):
    """Главное окно приложения: интерфейс и вызов вычислений."""
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Теория информации — ЛР: совместные и условные вероятности (PySide6)")
        self.resize(1180, 720)
```
> Создаёт основное окно приложения и задаёт заголовок/размер.

#### Верхняя панель: выбор случая и размеров

``` python 
        # ===== Верхняя панель =====
        topBox = QGroupBox("Выбор случая и размеров")
        topLay = QGridLayout(topBox)
        self.caseCombo = QComboBox()
        # Обновлённые формулировки
        self.caseCombo.addItems([
            "a) Дана матрица совместных вероятностей P(A,B)",
            "b) Дана матрица условных вероятностей P(A|B) и ансамбль B",
            "c) Дана матрица условных вероятностей P(B|A) и ансамбль A"
        ])
        self.spinRows = QSpinBox(); self.spinRows.setRange(2, 20); self.spinRows.setValue(2)
        self.spinCols = QSpinBox(); self.spinCols.setRange(2, 20); self.spinCols.setValue(4)
        self.variantEdit = QLineEdit(); self.variantEdit.setPlaceholderText("Номер варианта (необязательно)")
        btnResize = QPushButton("Задать размеры")
        btnResize.clicked.connect(self.apply_sizes)
        topLay.addWidget(QLabel("Случай:"),        0, 0)
        topLay.addWidget(self.caseCombo,           0, 1, 1, 3)
        topLay.addWidget(QLabel("Строк (|A|):"),   1, 0)
        topLay.addWidget(self.spinRows,            1, 1)
        topLay.addWidget(QLabel("Столбцов (|B|):"),1, 2)
        topLay.addWidget(self.spinCols,            1, 3)
        topLay.addWidget(QLabel("Вариант:"),       2, 0)
        topLay.addWidget(self.variantEdit,         2, 1, 1, 2)
        topLay.addWidget(btnResize,                2, 3)
```
> Шапка формы. Здесь выбирается тип исходных данных (a/b/c), задаются размеры множеств |A| и |B|, при желании вводится «номер варианта». Кнопка «Задать размеры» пересоздаёт таблицы нужных размеров.

#### Область ввода данных

``` python 
        # ===== Ввод =====
        self.matJoint     = MatrixInput("Матрица совместных вероятностей P(A,B)", 2, 4)
        self.matA_given_B = MatrixInput("Матрица условных вероятностей P(A|B) (столбцы суммируются к 1)", 2, 4)
        self.vecB         = VectorInput("Ансамбль B (вектор вероятностей)", 4)

        self.matB_given_A = MatrixInput("Матрица условных вероятностей P(B|A) (строки суммируются к 1)", 2, 4)
        self.vecA         = VectorInput("Ансамбль A (вектор вероятностей)", 2)
```
> Создаёт все нужные панели ввода: матрица P(A,B); матрица P(A|B) + вектор P(B); матрица P(B|A) + вектор P(A).

#### Кнопки управления и окно вывода

``` python 
        # ===== Кнопки =====
        ctrlLay = QHBoxLayout()
        self.btnCalc  = QPushButton("Рассчитать")
        self.btnClear = QPushButton("Очистить ввод")
        ctrlLay.addWidget(self.btnCalc)
        ctrlLay.addWidget(self.btnClear)

        self.btnCalc.clicked.connect(self.compute)
        self.btnClear.clicked.connect(self.clear_inputs)

        # ===== Протокол =====
        self.out = QPlainTextEdit()
        self.out.setReadOnly(True)
        monofont = QFont("Menlo", 14) if QFont("Menlo").exactMatch() else QFont("Courier New", 14)
        self.out.setFont(monofont)
```
> Кнопки «Рассчитать» (запускает вычисления) и «Очистить ввод» (стирает таблицы). Правую часть окна занимает QPlainTextEdit для протокола — моноширинный шрифт для аккуратных таблиц.

#### Компоновка на форме и первичная инициализация

``` python 
        # ===== Компоновка =====
        left = QVBoxLayout()
        left.addWidget(topBox)
        self.inputsBox = QGroupBox("Ввод данных")
        self.inputsLay = QVBoxLayout(self.inputsBox)
        left.addWidget(self.inputsBox)
        left.addLayout(ctrlLay)

        root = QHBoxLayout(self)
        root.addLayout(left, 1)
        root.addWidget(self.out, 1)

        # Инициализация
        self.apply_sizes()
        self.update_inputs_visibility()
        self.caseCombo.currentIndexChanged.connect(self.update_inputs_visibility)
```
> Собирает всё в единую форму: слева — шапка, блок ввода и кнопки; справа — окно вывода. При запуске выставляет размеры, показывает нужные панели для выбранного случая и подписывается на изменение выпадающего списка.

#### Вспомогательные методы интерфейса

``` python 
    def _commit_table(self, tbl: QTableWidget):
        for i in range(tbl.rowCount()):
            for j in range(tbl.columnCount()):
                it = tbl.item(i, j)
                if it is not None:
                    tbl.closePersistentEditor(it)
        tbl.setCurrentCell(-1, -1)

    def _commit_all_edits(self):
        for tbl in [self.matJoint.table, self.matA_given_B.table, self.matB_given_A.table,
                    self.vecA.table, self.vecB.table]:
            self._commit_table(tbl)
```
> Закрывают активные редакторы ячеек, чтобы перед чтением таблиц значения точно были сохранены (иначе пользователь мог не «подтвердить» ввод).

#### Переключение режимов a/b/c

``` python 
    def update_inputs_visibility(self):
        for i in reversed(range(self.inputsLay.count())):
            w = self.inputsLay.itemAt(i).widget()
            if w:
                w.setParent(None)
        case = self.caseCombo.currentIndex()
        if case == 0:
            self.inputsLay.addWidget(self.matJoint)
        elif case == 1:
            self.inputsLay.addWidget(self.matA_given_B)
            self.inputsLay.addWidget(self.vecB)
        else:
            self.inputsLay.addWidget(self.matB_given_A)
            self.inputsLay.addWidget(self.vecA)
        self.apply_sizes()
```
> Показывает ровно те поля ввода, которые нужны для выбранного режима. После перестановки обновляет подписи/размеры.

#### Обработчик «Рассчитать»: чтение ввода → расчёт → форматированный вывод

``` python 
    def compute(self):
        self.out.clear()
        self._commit_all_edits()

        case = self.caseCombo.currentIndex()
        variant = self.variantEdit.text().strip() or "—"

        try:
            if case == 0:
                Pab = self.matJoint.read()
                res = C.from_joint(Pab)
                header = "Случай a) дана матрица совместных вероятностей P(A,B)"
            elif case == 1:
                PA_B = self.matA_given_B.read()
                Pb   = self.vecB.read()
                res  = C.from_A_given_B_and_B(PA_B, Pb)
                header = "Случай b) дана матрица условных вероятностей P(A|B) и ансамбль B"
            else:
                PB_A = self.matB_given_A.read()
                Pa   = self.vecA.read()
                res  = C.from_B_given_A_and_A(PB_A, Pa)
                header = "Случай c) дана матрица условных вероятностей P(B|A) и ансамбль A"
        except Exception as e:
            self.out.setPlainText(f"Ошибка: {e}")
            return

        # вывод
        lines = []
        lines.append(self._sep())
        lines.append(f"Вариант: {variant}")
        lines.append(header)
        lines.append(self._sep())

        lines.append("Матрица совместных вероятностей P(A,B):")
        lines.append(U.fmt_matrix(res["Pab"], prec=4))

        Pa_disp = res["Pab"].sum(axis=1)
        Pb_disp = res["Pab"].sum(axis=0)

        lines.append(self._sep())
        lines.append("Ансамбль A")
        lines.append(f"P(A) = {U.fmt_vector(Pa_disp, prec=4)}")
        lines.append("Ансамбль B")
        lines.append(f"P(B) = {U.fmt_vector(Pb_disp, prec=4)}")

        lines.append(self._sep())
        lines.append("Матрица условных вероятностей P(B|A):")
        lines.append(U.fmt_matrix(res["PB_A"], prec=4))
        lines.append("Матрица условных вероятностей P(A|B):")
        lines.append(U.fmt_matrix(res["PA_B"], prec=4))

        lines.append(self._sep())
        lines.append("Результаты (в битах):")
        lines.append(f"H(A)   = {U.fmt_num(res['HA'], 8)}")
        lines.append(f"H(B)   = {U.fmt_num(res['HB'], 8)}")
        lines.append(f"H(A,B) = {U.fmt_num(res['HAB'], 8)}")
        lines.append(f"H(A|B) = {U.fmt_num(res['HA_B'], 8)}")
        lines.append(f"H(B|A) = {U.fmt_num(res['HB_A'], 8)}")
        lines.append(f"I(A;B) = {U.fmt_num(res['IAB'], 8)}")
        lines.append(self._sep())

        self.out.setPlainText("\n".join(lines))
```
> 	1.	Очищает окно вывода и фиксирует ввод.
> 	2.	По выбранному случаю читает соответствующие таблицы и вызывает нужную функцию из calcs.py.
> 	3.	Собирает человеко-читаемый протокол: совместная матрица, «ансамбль A/B», условные матрицы и информационные величины (в битах). Числа форматируются через utils.py.

#### Точка входа (запуск приложения)

``` python 
if __name__ == "__main__":
    app = QApplication(sys.argv)
    w = MainWin()
    w.show()
    sys.exit(app.exec())
```
> Стандартный запуск Qt-приложения: создаёт объект приложения, окно MainWin, показывает его и запускает цикл обработки событий.

### Объяснение кода calcs.py

#### Импорты и настройки

``` python 
import numpy as np

# Энтропии в битах
LOG2 = True
EPS  = 1e-8
```
> Подключаем numpy.
> LOG2 = True — логарифм по основанию 2 ⇒ все энтропии в битах.
> EPS = 1e-8 — маленький допуск для «безопасных» сравнений с нулём (избежать деления на 0 и артефактов).

#### Безопасный логарифм (обрабатываем log(0))

``` python 
def _safe_log(p: np.ndarray) -> np.ndarray:
    p = np.asarray(p, dtype=float)
    with np.errstate(divide='ignore', invalid='ignore'):
        out = np.log2(p) if LOG2 else np.log(p)
    out[~np.isfinite(out)] = 0.0  # log(0) -> 0 в суммах энтропии
    return out
```
> Преобразуем p к float и считаем log2(p) (или ln(p), если сменить режим). Для p=0 логарифм формально -∞, но в энтропии используется предел 0·log(0)=0, поэтому все нечисловые/бесконечные значения заменяем на 0.0.

#### Энтропия распределения (ансамбля или матрицы)

``` python 
def entropy(p: np.ndarray) -> float:
    p = np.asarray(p, dtype=float)
    return float(-np.nansum(p * _safe_log(p)))
```
> Реализация формулы Шеннона
> Работает и для вектора (даёт H(A) или H(B)), и для матрицы (даёт H(A,B)), т.к. суммирование идёт по всем элементам.

#### Безопасное деление по осям (для матриц условных вероятностей)

``` python 
def _safe_div(num: np.ndarray, den: np.ndarray, axis: int) -> np.ndarray:
    num = np.asarray(num, dtype=float)
    den = np.asarray(den, dtype=float)
    if axis == 1:
        return np.divide(num, den[np.newaxis, :],
                         out=np.zeros_like(num),
                         where=(np.abs(den[np.newaxis, :]) > EPS))
    elif axis == 0:
        return np.divide(num, den[:, np.newaxis],
                         out=np.zeros_like(num),
                         where=(np.abs(den[:, np.newaxis]) > EPS))
    raise ValueError("axis must be 0 (rows) or 1 (cols)")
```
> Универсальная обёртка для вычисления условных;
> 
> axis=1 — делим по столбцам: P(A_i|B_j)=P(A_i,B_j)/P(B_j);
> 
> axis=0 — делим по строкам: P(B_j|A_i)=P(A_i,B_j)/P(A_i);
> 
> Если знаменатель ≈0, пишем 0 (вместо nan/inf), что соответствует «условная не определена → принимаем 0».

#### Валидации входа

``` python 
# -------- Валидации --------
def validate_joint(Pab: np.ndarray):
    P = np.asarray(Pab, dtype=float)
    if (P < -EPS).any():
        raise ValueError("В P(A,B) есть отрицательные элементы.")
    s = P.sum()
    if s <= EPS:
        raise ValueError("Сумма P(A,B) равна нулю.")
    return P
```
> Проверяем: нет отрицательных значений и суммарная масса > 0.

``` python 
def validate_cond_A_given_B(PA_B: np.ndarray):
    M = np.asarray(PA_B, dtype=float)
    if (M < -EPS).any():
        raise ValueError("В P(A|B) есть отрицательные элементы.")
    col_sums = M.sum(axis=0)
    if not np.allclose(col_sums, 1.0, atol=1e-6):
        raise ValueError("Каждый столбец P(A|B) должен суммироваться к 1.")
    return M
```
> В P(A|B) каждый столбец — распределение по A при фиксированном B=j, значит сумма столбца ≈ 1.

``` python 
def validate_cond_B_given_A(PB_A: np.ndarray):
    M = np.asarray(PB_A, dtype=float)
    if (M < -EPS).any():
        raise ValueError("В P(B|A) есть отрицательные элементы.")
    row_sums = M.sum(axis=1)
    if not np.allclose(row_sums, 1.0, atol=1e-6):
        raise ValueError("Каждая строка P(B|A) должна суммироваться к 1.")
    return M
```
> В P(B|A) каждая строка — распределение по B при фиксированном A=i, значит сумма строки ≈ 1.

``` python 
def validate_vector(p: np.ndarray):
    v = np.asarray(p, dtype=float).ravel()
    if (v < -EPS).any():
        raise ValueError("В ансамбле есть отрицательные элементы.")
    s = v.sum()
    if not np.isclose(s, 1.0, atol=1e-6):
        raise ValueError("Ансамбль должен суммироваться к 1.")
    return v
```
> Для ансамблей проверяем корректность распределения: неотрицательно и сумма ≈ 1.

#### Случай (a): дана P(A,B)

``` python 
def from_joint(Pab: np.ndarray) -> dict:
    Pab = validate_joint(Pab)
    Pa = Pab.sum(axis=1)             # строки (A)
    Pb = Pab.sum(axis=0)             # столбцы (B)

    PA_B = _safe_div(Pab, Pb, axis=1)   # по столбцам
    PB_A = _safe_div(Pab, Pa, axis=0)   # по строкам
    HA  = entropy(Pa)
    HB  = entropy(Pb)
    HAB = entropy(Pab)
    HA_B = HAB - HB
    HB_A = HAB - HA
    IAB  = HA + HB - HAB

    return dict(
        Pab=Pab, Pa=Pa, Pb=Pb, PA_B=PA_B, PB_A=PB_A,
        HA=HA, HB=HB, HAB=HAB, HA_B=HA_B, HB_A=HB_A, IAB=IAB
    )
```
> Валидируем совместную матрицу.
> Считаем ансамбли
> Строим матрицы условных вероятностей
> энтропия и взаимная информация
> возвращаем все в одном словаре

#### Случай (b): даны P(A|B) и P(B)

``` python 
def from_A_given_B_and_B(PA_B: np.ndarray, Pb: np.ndarray) -> dict:
    PA_B = validate_cond_A_given_B(PA_B)
    Pb   = validate_vector(Pb)
    Pab  = PA_B * Pb[np.newaxis, :]
    return from_joint(Pab)
```
> Проверяем корректность P(A|B) (каждый столбец ≈1) и ансамбль P(B) (сумма ≈1).
> Восстанавливаем матрицу совместных вероятностей
> Далее считаем всё через общий путь from_joint().

#### Случай (c): даны P(B|A) и P(A)

``` python 
def from_B_given_A_and_A(PB_A: np.ndarray, Pa: np.ndarray) -> dict:
    PB_A = validate_cond_B_given_A(PB_A)
    Pa   = validate_vector(Pa)
    Pab  = (PB_A.T * Pa).T 
    return from_joint(Pab)
```
> Проверяем P(B|A) (каждая строка ≈1) и ансамбль P(A) (сумма ≈1).
> Восстанавливаем матрицу совместных вероятностей
> Далее считаем всё через общий путь from_joint().

### Объяснение кода utils.py

``` python 
def fmt_matrix(M, prec=4):
    """Форматирование матрицы с фиксированным числом знаков после запятой."""
    lines = []
    for row in M:
        line = ", ".join(f"{float(x):.{prec}f}" for x in row)
        lines.append(f"[{line}]")
    return "\n".join(lines)

def fmt_vector(v, prec=4):
    """Форматирование вектора с фиксированной точностью."""
    return "[" + ", ".join(f"{float(x):.{prec}f}" for x in v) + "]"

def fmt_num(x, prec=8):
    """Форматирование одного числа с фиксированной точностью."""
    return f"{float(x):.{prec}f}"
```
> utils.py содержит только служебные функции форматирования вывода.
> Они не участвуют в вычислениях и не изменяют результаты,
> а лишь отвечают за то, как данные (матрицы, векторы и числа) отображаются в окне программы.

