# Отчёт по лабораторной работе №3  
**Выполнил:** Шмелев Никита, группа 606-42  
## Тема: «Арифметическое кодирование»

---

### Интерфейс программы

На рисунке показано главное окно программы «Арифметическое кодирование».

Пользователь выполняет следующие действия:
- выбирает режим работы из выпадающего списка: «Кодирование» или «Декодирование»;
- вводит сообщение в текстовое поле («Введите сообщение для кодирования»).
В режиме декодирования вводится закодированное число или строка;
- запускает выполнение, нажимая кнопку «Выполнить».

После запуска программа:
- рассчитывает частоты появления символов исходного сообщения;
- определяет вероятности символов и формирует таблицу символов
(Символ, Вероятность, Нижняя граница, Верхняя граница);
- выполняет поэтапное арифметическое кодирование или декодирование;
- отображает таблицу шагов
(Шаг, Обрабатываемая цепочка, Текущий интервал);
- формирует итоговое значение — либо кодовое число, либо восстановленную строку.

В нижней части окна выводится блок «Результат», где представлено:
- окончательное закодированное значение (в режиме кодирования),
- восстановленное сообщение (в режиме декодирования),

Таким образом, окно программы обеспечивает полный визуальный контроль всех этапов арифметического кодирования и декодирования.

> **Рисунок 1 — Окно программы «Арифметическое кодирование» в режиме кодирования**
<img width="1458" height="850" alt="image" src="https://github.com/user-attachments/assets/584685a9-8590-49b7-81bc-2b6c9e8d35ed" />

> **Рисунок 2 — Окно программы «Арифметическое кодирование» в режиме декодирования**
<img width="1460" height="850" alt="image" src="https://github.com/user-attachments/assets/db0620c8-ead1-4481-a92d-1b7fb2af1d69" />

---

### Пример работы кода с сообщением из методички

> **Рисунок 3 — Расчёт для сообщения из методички**  
<img width="1466" height="856" alt="image" src="https://github.com/user-attachments/assets/feac379a-e5d2-41e6-9293-6af4dac7e75a" />


---


### Структура проекта

Код программы состоит из одного файла:
- arifcod.py — содержит весь функционал: интерфейс на PySide6, построение статистики символов, реализацию арифметического кодера/декодера, заполнение таблиц модели и шагов, а также вывод итогового результата.

---

### Объяснение кода arifcod.py

```python
import sys
import collections
from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional
from decimal import Decimal, getcontext

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget,
    QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QPlainTextEdit, QTableWidget, QTableWidgetItem,
    QGroupBox, QHeaderView, QComboBox
)
from PySide6.QtCore import Qt

getcontext().prec = 35
```
> Импортируются стандартные модули, типы, Decimal для точных вычислений и виджеты PySide6. getcontext().prec = 35 задаёт высокую точность десятичных вычислений, чтобы интервалы при арифметическом кодировании не «сыпались» от ошибок округления.
```python
@dataclass
class SymbolStat:
    symbol: str
    count: int
    prob: Decimal
    low: Decimal = Decimal(0)
    high: Decimal = Decimal(0)
```
> Dataclass для одного символа источника: сам символ, его частота, вероятность, а также нижняя и верхняя границы интервала [low; high) на отрезке [0;1].
```python
def build_stats(text: str) -> List[SymbolStat]:
    """Строим список SymbolStat: частоты, вероятности и интервалы [low; high)."""
    if not text:
        return []

    freq = collections.Counter(text)
    total = sum(freq.values())

    items = sorted(freq.items(), key=lambda kv: (-kv[1], kv[0]))
    stats: List[SymbolStat] = []
    for ch, c in items:
        p = Decimal(c) / Decimal(total)
        stats.append(SymbolStat(ch, c, p))

    cur = Decimal(0)
    for s in stats:
        s.low = cur
        s.high = cur + s.prob
        cur = s.high

    # Гарантируем, что у последнего high = 1
    if stats:
        stats[-1].high = Decimal(1)

    return stats
```
> Полная реализация build_stats:
    1.	Считает частоты Counter(text).
	2.	Сортирует символы по убыванию частоты (как удобно для моделей).
	3.	Вычисляет вероятности prob = count / total.
	4.	Последовательно размещает символы на оси [0;1], создавая интервалы [low; high).
	5.	Последнему символу гарантированно выставляет high = 1, чтобы избежать накопления ошибок округления.
```python
def build_ranges(stats: List[SymbolStat]) -> Dict[str, Tuple[Decimal, Decimal]]:
    """Строит словарь: символ -> (low, high)."""
    return {s.symbol: (s.low, s.high) for s in stats}
```
> Вспомогательный быстрый доступ к интервалам. Словарь: символ → его интервал.
```python
class ArithmeticCoder:
    def __init__(self, stats: List[SymbolStat]):
        self.stats = stats
        self.ranges = build_ranges(stats)
```
> Хранит модель источника и словарь интервалов.
```python
    def encode(self, text: str):
        """Кодирование. Возвращает список шагов и код (нижнюю границу)."""
        low = Decimal(0)
        high = Decimal(1)
        steps: List[Tuple[int, str, Decimal, Decimal]] = []

        steps.append((0, "Нет", low, high))
        prefix = ""

        for i, ch in enumerate(text, start=1):
            if ch not in self.ranges:
                raise ValueError(f"Символ '{ch}' отсутствует в модели")

            prefix += ch
            sym_low, sym_high = self.ranges[ch]
            rng = high - low

            new_low = low + rng * sym_low
            new_high = low + rng * sym_high
            low, high = new_low, new_high

            steps.append((i, prefix, low, high))

        code = low
        return steps, code
```
> Метод реализует стандартный алгоритм арифметического кодирования:
— начальный интервал [0;1];
— на каждом шаге интервал сужается пропорционально подынтервалу текущего символа;
— все шаги, включая промежуточные интервалы, записываются в steps;
— итоговый код — левая граница последнего интервала.
```python
    def decode(self, code: Decimal, max_length: int):
        """
        Декодирование по коду. Возвращает восстановленный текст и список шагов.
        """
        low = Decimal(0)
        high = Decimal(1)
        result = ""
        steps: List[Tuple[int, str, Decimal, Decimal]] = []
        steps.append((0, "Нет", low, high))

        ordered = sorted(self.stats, key=lambda s: s.low)

        for i in range(1, max_length + 1):
            rng = high - low
            if rng == 0:
                break

            norm = (code - low) / rng

            found = None
            for s in ordered:
                if s.low <= norm < s.high:
                    found = s
                    break

            if found is None:
                break

            result += found.symbol

            new_low = low + rng * found.low
            new_high = low + rng * found.high
            low, high = new_low, new_high

            steps.append((i, result, low, high))

            if code == low:
                break

        return result, steps
```
> Метод декодирования:
— нормирует код в текущем интервале;
— ищет символ, подынтервал которого содержит нормированное значение;
— добавляет его к результату;
— сужает интервал аналогично encode;
— если code == low, декодирование завершено (это точное попадание в левую границу одного из шагов).
```python
class ModelTable(QTableWidget):
    def __init__(self, parent=None):
        super().__init__(0, 4, parent)
        self.setHorizontalHeaderLabels([
            "Символ", "Вероятность", "Нижняя граница", "Верхняя граница"
        ])
        header = self.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.Stretch)
        self.verticalHeader().setVisible(False)
        self.setAlternatingRowColors(True)
        self.setWordWrap(False)
```
> Таблица для модели источника.
```python
    def populate(self, stats: List[SymbolStat]):
        self.setRowCount(0)
        for s in stats:
            row = self.rowCount()
            self.insertRow(row)
            values = [s.symbol, str(s.prob), str(s.low), str(s.high)]
            for col, val in enumerate(values):
                it = QTableWidgetItem(val)
                it.setTextAlignment(Qt.AlignCenter)
                it.setFlags(it.flags() & ~Qt.ItemIsEditable)
                self.setItem(row, col, it)
```
> Заполняет таблицу статистики.
```python
class StepsTable(QTableWidget):
    def __init__(self, parent=None):
        super().__init__(0, 3, parent)
        self.setHorizontalHeaderLabels(["Шаг", "Цепочка", "Интервал"])
        header = self.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.Stretch)
        self.verticalHeader().setVisible(False)
        self.setAlternatingRowColors(True)
        self.setWordWrap(False)
```
> Таблица шагов кодирования/декодирования.
```python
    def populate(self, steps: List[Tuple[int, str, Decimal, Decimal]]):
        self.setRowCount(0)
        for step, chain, low, high in steps:
            row = self.rowCount()
            self.insertRow(row)
            interval_str = f"[{low}; {high})"
            vals = [str(step), chain, interval_str]
            for col, val in enumerate(vals):
                it = QTableWidgetItem(val)
                it.setTextAlignment(Qt.AlignCenter)
                it.setFlags(it.flags() & ~Qt.ItemIsEditable)
                self.setItem(row, col, it)
```
> Выводит шаги: номер шага, текущую цепочку, соответствующий интервал.
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Арифметическое кодирование (ЛР 3)")

        self.current_stats: List[SymbolStat] = []
        self.current_text_length: int = 0

        central = QWidget()
        self.setCentralWidget(central)
        root = QVBoxLayout(central)
```
> Создаёт окно и корневой layout. Хранит модель и длину последнего кодированного текста.
```python
        top_box = QGroupBox()
        top_layout = QHBoxLayout(top_box)

        lbl_mode = QLabel("Режим:")
        self.modeCombo = QComboBox()
        self.modeCombo.addItems(["Кодирование", "Декодирование"])
        self.modeCombo.currentTextChanged.connect(self.update_mode_ui)

        self.btnRun = QPushButton("Выполнить")
        self.btnRun.clicked.connect(self.on_run)

        top_layout.addWidget(lbl_mode)
        top_layout.addWidget(self.modeCombo, 1)
        top_layout.addWidget(self.btnRun)
        root.addWidget(top_box)
```
> Режим: кодирование или декодирование.Кнопка запуска вызывает нужный обработчик.
```python
        self.txtInput = QPlainTextEdit()
        root.addWidget(self.txtInput)

        self.modelTable = ModelTable()
        self.tblSteps = StepsTable()
        ...
        # Нижний блок "Результат"
        self.resultView = QPlainTextEdit()
        self.resultView.setReadOnly(True)
        root.addWidget(self.resultView, 1)

        self.update_mode_ui()
```
> Ввод строки, таблица статистики, таблица шагов, поле результатов.
```python
    def update_mode_ui(self):
        mode = self.modeCombo.currentText()
        if mode == "Кодирование":
            self.txtInput.setPlaceholderText("Введите сообщение для кодирования")
        else:
            self.txtInput.setPlaceholderText("Введите код (десятичную дробь, можно с запятой)")

        self.tblSteps.setRowCount(0)
        self.resultView.clear()
        self.modelTable.setRowCount(0)
```
> Меняет подсказку и очищает интерфейс при переключении режима.
```python
    def on_run(self):
        if self.modeCombo.currentText() == "Кодирование":
            self.run_encode()
        else:
            self.run_decode()
```
> В зависимости от режима — кодирование или декодирование.
```python
    def run_encode(self):
        text = self.txtInput.toPlainText()
        if not text:
            self.resultView.setPlainText("Введите текст для кодирования.")
            return

        stats = build_stats(text)
        if not stats:
            return

        coder = ArithmeticCoder(stats)
        try:
            steps, code = coder.encode(text)
        except Exception as e:
            self.resultView.setPlainText(f"Ошибка кодирования: {e}")
            self.tblSteps.setRowCount(0)
            return

        self.current_stats = stats
        self.current_text_length = len(text)

        self.modelTable.populate(stats)
        self.tblSteps.populate(steps)

        low = steps[-1][2]
        high = steps[-1][3]
        res_text = (
            "Результат кодирования:\n"
            f"{code}\n\n"
            "Интервал:\n"
            f"[{low}; {high})\n\n"
            "Длина сообщения:\n"
            f"{len(text)}"
        )
        self.resultView.setPlainText(res_text)
```
> Основной процесс: строится модель, кодер формирует шаги и код, таблицы заполняются.
```python
    def run_decode(self):
        if not self.current_stats or self.current_text_length <= 0:
            self.resultView.setPlainText(
                "Нет данных для декодирования.\n"
                "Сначала выполните кодирование, чтобы построить модель и зафиксировать длину сообщения."
            )
            self.tblSteps.setRowCount(0)
            return

        code_str = self.txtInput.toPlainText().strip()
        if not code_str:
            self.resultView.setPlainText("Введите код для декодирования.")
            self.tblSteps.setRowCount(0)
            return

        try:
            code = Decimal(code_str.replace(",", "."))
        except Exception as e:
            self.resultView.setPlainText(f"Некорректный код: {e}")
            self.tblSteps.setRowCount(0)
            return

        max_len = self.current_text_length
        coder = ArithmeticCoder(self.current_stats)

        try:
            text, steps = coder.decode(code, max_len)
        except Exception as e:
            self.resultView.setPlainText(f"Ошибка декодирования: {e}")
            self.tblSteps.setRowCount(0)
            return

        self.modelTable.populate(self.current_stats)
        self.tblSteps.populate(steps)

        res_text = (
            "Результат декодирования:\n"
            f"{text}\n\n"
            f"Длина восстановленной строки: {len(text)}"
        )
        self.resultView.setPlainText(res_text)
```
> Декодирование использует сохранённую модель и длину сообщения. Ошибки корректно обрабатываются — неверный код, пустая модель и т.д.

```python
if __name__ == "__main__":
    app = QApplication(sys.argv)
    w = MainWindow()
    w.showMaximized()
    sys.exit(app.exec())
```
> Создаёт приложение Qt, окно программы и запускает главный цикл.

