# Отчёт по лабораторной работе №4  
**Выполнил:** Шмелев Никита, группа 606-42  
## Тема: «Помехоустойчивое кодирование»

---

### Интерфейс программы

На рисунке показано главное окно программы «Код Хэмминга (ЛР 4)».
Пользователь выполняет следующие действия:

#### Кодирование
- вводит двоичную последовательность в поле «Ввод»;
- нажимает «Рассчитать».

Программа:
- определяет позиции контрольных битов (1, 2, 4, 8, …);
- выводит таблицу с контролируемыми позициями и рассчитанными значениями контрольных разрядов;
- формирует итоговое кодовое слово Хэмминга.

В нижней части отображается строка:
Код Хэмминга: XXXXXXXX

#### Декодирование

Пользователь:
- вводит принятое (возможно искажённое) кодовое слово;
- нажимает «Рассчитать».

Программа:
- пересчитывает контрольные биты;
- формирует синдром ошибки S — двоичное число из значений контрольных разрядов;
- если S ≠ 0, определяет позицию ошибочного бита и исправляет его;
- показывает результат: исходное слово, выделение ошибочного разряда и исправленную последовательность.

> **Рисунок 1 — Главное окно программы «Код Хэмминга»**
<img width="544" height="671" alt="image" src="https://github.com/user-attachments/assets/ab3d1c5a-e587-4645-9a04-f7c0f57b4d7d" />

---

### Пример работы кода

> **Рисунок 2 — Расчёт для сообщения 0010 и нахождения специльно допущенной ошибки**  

<img width="539" height="672" alt="image" src="https://github.com/user-attachments/assets/f8667b80-2602-4495-8d02-da5bf70ef9fd" />


---


### Структура проекта

Код программы состоит из одного файла:
• l4.py — содержит весь функционал: интерфейс PySide6, вычисление контрольных битов, формирование кодового слова Хэмминга, поиск ошибки при декодировании, построение синдрома и исправление ошибочного бита, а также заполнение таблиц в графическом интерфейсе.

---

### Логика кодирования и декодирования

**Формирование кодового слова (кодирование)**
- needed_parity_bits(m) — считает количество контрольных битов.
- positions_for_parity(n, p) — возвращает список позиций, контролируемых битом p.
- run_encode() — формирует кодовое слово Хэмминга и таблицу контрольных битов.

**Поиск ошибок и исправление (декодирование)**
- positions_for_parity(n, p) — те же контролируемые позиции.
- run_decode() — пересчитывает контрольные биты, формирует синдром и исправляет ошибку.


---

### Объяснение кода l4.py
```python
import sys
from typing import List

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget,
    QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton,
    QTableWidget, QTableWidgetItem, QHeaderView, QGroupBox, QFrame
)
from PySide6.QtCore import Qt
```
> Здесь подключаются модули PySide6 для создания окон, кнопок, таблиц и элементов интерфейса, типы данных из typing, а также системный модуль sys. Эти библиотеки обеспечивают работу графического интерфейса программы.
```python
def is_binary_string(s: str) -> bool:
    return all(ch in "01" for ch in s) and len(s) > 0
```
> Проверяет, что строка состоит только из символов 0 и 1.
```python
def needed_parity_bits(m: int) -> int:
    r = 0
    while (2 ** r) < m + r + 1:
        r += 1
    return r
```
> Вычисляет минимальное количество контрольных битов r по формуле Хэмминга **2^r ≥ m + r + 1**.
```python
def positions_for_parity(n: int, p: int) -> List[int]:
    return [i for i in range(1, n + 1) if i & p]
```
> Возвращает список позиций, контролируемых контрольным битом с номером p. Используется классическое побитовое правило Хэмминга.
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Код Хэмминга (ЛР 4)")

        central = QWidget()
        self.setCentralWidget(central)
        root = QVBoxLayout(central)

        # ===== КОДИРОВАНИЕ =====
        enc_group = QGroupBox("Кодирование")
        enc_layout = QVBoxLayout(enc_group)

        enc_input_row = QHBoxLayout()
        enc_input_row.addWidget(QLabel("Ввод:"))
        self.encInput = QLineEdit()
        enc_input_row.addWidget(self.encInput, 1)

        self.btnEnc = QPushButton("Рассчитать")
        self.btnEnc.clicked.connect(self.run_encode)
        enc_input_row.addWidget(self.btnEnc)

        enc_layout.addLayout(enc_input_row)

        # Таблица контрольных битов (кодирование)
        self.encTable = QTableWidget(0, 3)
        self.encTable.setHorizontalHeaderLabels(
            ["Контр. бит", "Контролируемые позиции", "Знач."]
        )
        enc_header = self.encTable.horizontalHeader()
        enc_header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        enc_header.setSectionResizeMode(1, QHeaderView.Stretch)
        enc_header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.encTable.verticalHeader().setVisible(False)
        enc_layout.addWidget(self.encTable)

        # Строка с кодом Хэмминга
        enc_code_row = QHBoxLayout()
        enc_code_row.addWidget(QLabel("Код Хэмминга:"))
        self.encCodeEdit = QLineEdit()
        self.encCodeEdit.setReadOnly(True)
        enc_code_row.addWidget(self.encCodeEdit, 1)
        enc_layout.addLayout(enc_code_row)

        root.addWidget(enc_group)

        # ===== ДЕКОДИРОВАНИЕ =====
        dec_group = QGroupBox("Декодирование")
        dec_layout = QVBoxLayout(dec_group)

        dec_input_row = QHBoxLayout()
        dec_input_row.addWidget(QLabel("Ввод:"))
        self.decInput = QLineEdit()
        dec_input_row.addWidget(self.decInput, 1)

        self.btnDec = QPushButton("Рассчитать")
        self.btnDec.clicked.connect(self.run_decode)
        dec_input_row.addWidget(self.btnDec)

        dec_layout.addLayout(dec_input_row)

        # Таблица контрольных битов (декодирование)
        self.decTable = QTableWidget(0, 3)
        self.decTable.setHorizontalHeaderLabels(
            ["Контр. бит", "Контролируемые позиции", "Знач."]
        )
        dec_header = self.decTable.horizontalHeader()
        dec_header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        dec_header.setSectionResizeMode(1, QHeaderView.Stretch)
        dec_header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
        self.decTable.verticalHeader().setVisible(False)
        dec_layout.addWidget(self.decTable)

        # Строка: синдром
        self.syndromeLabel = QLabel("")
        dec_layout.addWidget(self.syndromeLabel)

        # Таблица результата декодирования — одна строка, фиксированная высота
        dec_layout.addWidget(
            QLabel("Результат декодирования")
        )
        self.resultTable = QTableWidget(1, 0)
        self.resultTable.horizontalHeader().setVisible(False)
        self.resultTable.verticalHeader().setVisible(False)
        self.resultTable.setShowGrid(False)
        self.resultTable.setFrameShape(QFrame.NoFrame)
        self.resultTable.setFixedHeight(60)     # компактное окно
        self.resultTable.setRowHeight(0, 40)
        dec_layout.addWidget(self.resultTable)

        root.addWidget(dec_group)

        # Стартовый размер окна
        self.resize(550, 650)
```
> Здесь формируется всё графическое окно программы:
— блок «Кодирование» с полем ввода, кнопкой, таблицей контрольных битов и строкой итогового кода;
— блок «Декодирование» с полем ввода, таблицей пересчитанных битов, выводом синдрома и таблицей исправленного результата.
Этот код полностью отвечает за внешний вид программы и расположение всех элементов интерфейса.
```python
# ---------- КОДИРОВАНИЕ ----------

    def run_encode(self):
        s = self.encInput.text().strip().replace(" ", "")
        self.encTable.setRowCount(0)
        self.encCodeEdit.clear()

        if not is_binary_string(s):
            self.encCodeEdit.setText("Ошибка: нужны только 0 и 1")
            return

        m = len(s)
        r = needed_parity_bits(m)
        n = m + r

        # Расставляем информационные биты по позициям (1..n)
        code = ["0"] * (n + 1)  # индекс 0 не используем
        parity_positions = [2 ** i for i in range(r)]
        data_idx = 0
        for pos in range(1, n + 1):
            if pos in parity_positions:
                code[pos] = "0"  # временно
            else:
                code[pos] = s[data_idx]
                data_idx += 1

        # Считаем контрольные биты и заполняем таблицу
        for p in parity_positions:
            positions = positions_for_parity(n, p)
            parity = 0
            for idx in positions:
                parity ^= int(code[idx])
            code[p] = str(parity)

            row = self.encTable.rowCount()
            self.encTable.insertRow(row)

            it = QTableWidgetItem(str(p))
            it.setTextAlignment(Qt.AlignCenter)
            it.setFlags(it.flags() & ~Qt.ItemIsEditable)
            self.encTable.setItem(row, 0, it)

            pos_str = ",".join(str(idx) for idx in positions)
            it = QTableWidgetItem(pos_str)
            it.setTextAlignment(Qt.AlignCenter)
            it.setFlags(it.flags() & ~Qt.ItemIsEditable)
            self.encTable.setItem(row, 1, it)

            it = QTableWidgetItem(code[p])
            it.setTextAlignment(Qt.AlignCenter)
            it.setFlags(it.flags() & ~Qt.ItemIsEditable)
            self.encTable.setItem(row, 2, it)

        encoded = "".join(code[1:])
        self.encCodeEdit.setText(encoded)

```
> Этот метод выполняет кодирование Хэмминга:
— проверяет корректность входной строки;
— вычисляет количество контрольных битов;
— вставляет информационные биты на нужные позиции;
— пересчитывает значения контрольных битов;
— заполняет таблицу контрольных разрядов;
— выводит итоговое кодовое слово.

```python
# ---------- ДЕКОДИРОВАНИЕ ----------

    def run_decode(self):
        s = self.decInput.text().strip().replace(" ", "")
        self.decTable.setRowCount(0)
        self.resultTable.setColumnCount(0)
        self.syndromeLabel.setText("")

        if not is_binary_string(s):
            return

        n = len(s)
        parity_positions: List[int] = []
        p = 1
        while p <= n:
            parity_positions.append(p)
            p *= 2

        bits = list(s)
        syndromes: List[int] = []

        # считаем синдромы и заполняем таблицу
        for p in parity_positions:
            positions = positions_for_parity(n, p)
            parity = 0
            for idx in positions:
                parity ^= int(bits[idx - 1])

            syndromes.append(parity)

            row = self.decTable.rowCount()
            self.decTable.insertRow(row)

            it = QTableWidgetItem(str(p))
            it.setTextAlignment(Qt.AlignCenter)
            it.setFlags(it.flags() & ~Qt.ItemIsEditable)
            self.decTable.setItem(row, 0, it)

            pos_str = ",".join(str(idx) for idx in positions)
            it = QTableWidgetItem(pos_str)
            it.setTextAlignment(Qt.AlignCenter)
            it.setFlags(it.flags() & ~Qt.ItemIsEditable)
            self.decTable.setItem(row, 1, it)

            it = QTableWidgetItem(str(parity))
            it.setTextAlignment(Qt.AlignCenter)
            it.setFlags(it.flags() & ~Qt.ItemIsEditable)
            self.decTable.setItem(row, 2, it)

        # позиция ошибки = сумма номеров контрольных битов с синдромом 1
        error_pos = 0
        for p, s_bit in zip(parity_positions, syndromes):
            if s_bit == 1:
                error_pos += p

        # Для вывода синдрома показываем биты от старшего к младшему
        # (P8 P4 P2 P1 → S = 0011 = 3)
        syndrome_bits_for_print = list(reversed(syndromes))
        syndrome_str = "".join(str(b) for b in syndrome_bits_for_print)
        self.syndromeLabel.setText(f"S = {syndrome_str} = {error_pos}")

        # исправляем бит, если позиция корректная
        corrected = bits[:]
        if 1 <= error_pos <= n:
            corrected_bit = "1" if corrected[error_pos - 1] == "0" else "0"
            corrected[error_pos - 1] = corrected_bit

        # заполняем одну строку результата
        self.resultTable.setColumnCount(n)
        for col, ch in enumerate(corrected):
            it = QTableWidgetItem(ch)
            it.setTextAlignment(Qt.AlignCenter)
            it.setFlags(it.flags() & ~Qt.ItemIsEditable)
            if col + 1 == error_pos:
                it.setBackground(Qt.red)
            self.resultTable.setItem(0, col, it)

        self.resultTable.horizontalHeader().setSectionResizeMode(
            QHeaderView.ResizeToContents
        )
```
> Метод декодирования:
— пересчитывает контрольные биты;
— формирует синдром ошибки;
— определяет позицию ошибочного разряда;
— исправляет ошибку, если она есть;
— отображает синдром и итоговую исправленную строку в таблице.
```python
if __name__ == "__main__":
    app = QApplication(sys.argv)
    w = MainWindow()
    w.resize(550, 650)
    w.show()
    sys.exit(app.exec())
```
> Стандартный запуск приложения PySide6: создаётся объект окна и запускается главный цикл работы GUI.

